local AntiCheatNamecall

AntiCheatNamecall = hookmetamethod(game, "__namecall", newcclosure(function(Self, ...)
    local Arguments = {...}
    local AntiCheats = {"BreathingHAMON", "TeleportDetect", "JJARC", "TakePoisonDamage", "CHECKER_1", "CHECKER", "GUI_CHECK", "OneMoreTime", "checkingSPEED", "BANREMOTE", "PERMAIDBAN", "KICKREMOTE", "BR_KICKPC", "FORCEFIELD", "Christmas_Sock", "VirusCough", "Symbiote", "Symbioted", "RequestAFKDisplay"}
    
    if table.find(AntiCheats, Arguments[1]) and getnamecallmethod() == "FireServer" then
        return
    end
    
    return AntiCheatNamecall(Self, ...)
end))

getgenv().settings = {
    ["Aimlock"] = false, -- Aimlock toggle.
    ["AimlockPrediction"] = 5.3, -- Aimlock prediction
    ["Aimpart"] = "UpperTorso",-- Aimpart for lock --\\ Head | UpperTorso | LowerTorso | etc... //-- 
    ["Aimparts"] = { "Head", "UpperTorso","LowerTorso", "HumanoidRootPart" },
    ["AntiPosition"] = "Sky", -- Sky|Ground|Prediction
    -- \\ Locates it up in the Sky | Underground | Trolls The Locker | Disables the locker's prediction //
    ["Antilock"] = false, -- Anti Lock toggle.
    ["AutoArmour"] = false, -- Auto Buys Armour
    ["AutoFood"] = true, -- Auto Buys Food toggle.
    ["AutoPredict"] = true, -- Automatically predicts correctly (HIGHLY RECOMMENDED).
    ["AutoPrediction"] = 0.001772, -- Automatic camlock prediction based on ping (RECOMMENDED).
    ["AutoStomp"] = false, -- Auto Stomps toggle.
    ["AutoStompDelay"] = 0, -- Auto Stomp Delay \\ 0 = no delay // (Seconds).
    ["Camlock"] = false, -- CamLock toggle.
    ["Dot"] = false, -- Creates a dot on "Target".
    ["Prediction"] = 0.267, -- Manual camlock prediction.
    ["Resolver"] = false, -- Anti-Lock Resolver.
    ["ResolverType"] = "Recalculate velocity", -- Recalculate velocity|Move Direction|Zero
    ["Scriptable"] = false, -- Maybe a better camlock update? üó£üî•‚ÄºÔ∏è
    ["Silent"] = false, -- Silent CamLock toggle.
    ["Smoothing"] = true, -- Smoothes camlock camera movement.
    ["SmoothingAmount"] = 0.422, -- Smooth amount << Higher = Slower >>
    ["Target"] = nil, -- Person targeted.
    ["Strafe"] = { -- Target Strafe basically.
        ["Status"] = false,
        ["Speed"] = 70,
        ["Height"] = 20,
        ["Distance"] = 18
    },
    ["SilentVictim"] = "", -- Silent CamLock Target.
    ["view"] = false, -- View toggle.
    ["whitelist"] = {}, -- Whitelisted players.
    ["AutoTactical"] = false, -- Auto buys tactical.
    ["RefreshRate"] = 30 -- Resolver refresh rate.
}
local ButtonsModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/3isht/3isht/master/ModuleTest.lua"))()
local me = game.Players.LocalPlayer
local rs = game:GetService("RunService")
local cc, mt = game.workspace.CurrentCamera, getrawmetatable(game)
settings.offset = 2.77
local value, ping, armour, lockbutton, silentbutton, armourbutton, basket, tac, usp, sg

print("Auto prediction\n0.001812\nSmoothening amount\n0.422")
print("Auto prediction\n0.001769\nSmoothening amount\n0.422")


local dot = Drawing.new("Circle")
dot.Visible = false
dot.Filled = true
dot.Thickness = 1
dot.Radius = 3
dot.Color = Color3.fromRGB(175,30,0)

--// ChatSpy \\--
loadstring(game:HttpGet("https://raw.githubusercontent.com/3isht/3isht/master/chatspy"))()

function autostomp()
    while settings["AutoStomp"] do
        game:GetService("ReplicatedStorage"):WaitForChild("MAINEVENT"):FireServer("STOMP")
        --if settings["AutoStompDelay"] > 0 then
          --  task.wait(settings["AutoStompDelay"])
        --end
        
        if not settings["AutoStomp"] then break end
    end
end

local getarmour = function()
    for _, child in game.workspace:GetDescendants() do
        if child.Name:lower() == "[high-medium armor]" and child:FindFirstChildWhichIsA("ClickDetector") then
            return child end
        if child.Name:lower() == "[medium armor]" and child:FindFirstChildWhichIsA("ClickDetector") then
            return child end
    end
end
local gettac = function()
    for _,child in game.workspace:GetDescendants() do
        if child.Name == "[Tactical Shotgun]" and child:FindFirstChildWhichIsA("ClickDetector") then
            return child end
    end
end
armour = getarmour()
tac = gettac()

-- Returns a table.
function getfood()
    local f = {}
    local succ, err = pcall(function()
        for _, v in next, game.workspace:GetDescendants() do
            if v.Name:lower() == "[pizza]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
            if v.Name:lower() == "[burger]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
            if v.Name:lower() == "[donut]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
            if v.Name:lower() == "[popcorn]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
            if v.Name:lower() == "[chicken]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
        end
    end)
    if err then
        print("Something errored in getfood() : "..err)
    end
    return f
end

basket = getfood()

-- Returns Player Full Form.
function getnear()
    local max = math.huge
    local distance = nil
    local nearest = nil
    for i, player in game.Players:GetChildren() do
        if player.Name ~= me.Name and not game.workspace[player.Name]:GetAttribute("Knocked") and not table.find(settings["whitelist"], player.Name) then
            distance = (me.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude
            if distance < max then
                max = distance
                nearest = player
            end
        end
    end
    return nearest
end

-- Returns a string (username).
function getuser(inp)
    if inp == " " or inp == "" then return end
    local low = inp:lower()
    for _,v in next, game.Players:GetChildren() do
        if string.sub(v.Name:lower(),1,#low) == low or string.sub(v.DisplayName:lower(),1,#low) == low and v.Name ~= me.Name then
            return v.Name
        end
    end
end

function Notify(name,desc,dur)
    game.StarterGui:SetCore("SendNotification", {
        Title = name,
        Text = desc,
        Duration = dur
    })
end

function resolve(name)
    if settings["ResolverType"] == "Recalculate velocity" then
        print("Worked here")
        local noob = game.Players[name]
        local oldPos, oldTick = noob.Character["Aimpart"].Position, tick()
        task.wait()
        local newPos = noob.Character.HumanoidRootPart.Position
        local newTick = tick()
        local Time = newTick - oldTick
        local newVel = (newPos - oldPos) / Time
        
        if tick() - oldTick >= 1 / settings["RefreshRate"] then
            oldTick, oldPos = newTick, newPos
        end
        print(newVel)
        return newVel
    elseif settings["ResolverType"] == "Zero" then
        print("Returned 0")
        return Vector3.new(0,0,0)
    end
end

function camlock()
    task.spawn(function()
        local noob = game.Players[settings["Target"]]
        local calculation, mag, goal
        local type = cc.CameraType
        task.wait()
        if settings["Scriptable"] then cc.CameraType = Enum.CameraType.Scriptable end
        while task.wait() do
            if settings["Camlock"] and settings["Target"] ~= me.Name and not game.workspace[settings["Target"]]:GetAttribute("Knocked") then
                local ALV = noob.Character[settings["Aimpart"]].AssemblyLinearVelocity
                if noob and not game.workspace[noob.Name]:GetAttribute("Knocked") then
                    if settings["Smoothing"] then
                        if settings["AutoPredict"] then
                            mag = (noob.Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        else 
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset) ,ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        end
                        if settings["Resolve"] then
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(resolve(noob.Name).X * (mag * (ping * settings["AutoPrediction"])), resolve(noob.Name).Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), resolve(noob.Name).Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            else 
                                calculation = Vector3.new(resolve(noob.Name).X * (mag * (ping * settings["Prediction"])), resolve(noob.Name).Y * ((mag * (ping * settings["Prediction"]))/settings.offset), resolve(noob.Name).Z * (mag * (ping * settings["Prediction"])))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            end
                        end
                    else
                        if settings["AutoPredict"] then
                            mag = (noob.Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        else 
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]),noob.Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        end
                        if settings["Resolve"] then
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(resolve(noob.Name).X * (mag * (ping * settings["AutoPrediction"])), resolve(noob.Name).Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), resolve(noob.Name).Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            else 
                                calculation = Vector3.new(resolve(noob.Name).X * (mag * (ping * settings["Prediction"])), resolve(noob.Name).Y * ((mag * (ping * settings["Prediction"]))/settings.offset), resolve(noob.Name).Z * (mag * (ping * settings["Prediction"])))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            end
                        end
                    end
                end
            end
            if not settings["Camlock"] or not game.Players[settings["Target"]] then break end
        end
    end)
end

function silentlock()
    task.spawn(function()
        settings["SilentVictim"] = getnear()
        local calculation, mag, goal
        local type = cc.CameraType
        task.wait()
        if settings["Scriptable"] then cc.CameraType = Enum.CameraType.Scriptable end
        Notify("Silent Notif", "  Silent: "..settings["SilentVictim"].Name, 1)
        while task.wait() do
            if settings["Silent"] and settings["SilentVictim"] and not table.find(settings["whitelist"], settings["SilentVictim"].Name) and not game.workspace[settings["SilentVictim"].Name]:GetAttribute("Knocked") then
                local ALV = settings["SilentVictim"].Character[settings["Aimpart"]].AssemblyLinearVelocity
                if settings["Smoothing"] then
                    if settings["AutoPredict"] then
                        mag = (settings["SilentVictim"].Character.Humanoid.MoveDirection).magnitude
                        
                        calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                        goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                        cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                    else
                        calculation = Vector3.new(ALV.X * (settings["Prediction"]),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                        goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                        cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                    end
                    if settings["Resolve"] then
                        if settings["AutoPredict"] then
                            calculation = Vector3.new(resolve(settings["SilentVictim"].Name).X * (mag * (ping * settings["AutoPrediction"])), resolve(settings["SilentVictim"].Name).Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), resolve(settings["SilentVictim"].Name).Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        else 
                            calculation = Vector3.new(resolve(settings["SilentVictim"].Name).X * (mag * (ping * settings["Prediction"])), resolve(settings["SilentVictim"].Name).Y * ((mag * (ping * settings["Prediction"]))/settings.offset), resolve(settings["SilentVictim"].Name).Z * (mag * (ping * settings["Prediction"])))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        end
                    end
                else
                    if settings["AutoPredict"] then
                        mag = (settings["SilentVictim"].Character.Humanoid.MoveDirection).magnitude
                        
                        calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                        goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                        cc.CFrame = goal
                    else
                        calculation = Vector3.new(ALV.X * (settings["Prediction"]),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                        goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                        cc.CFrame = goal
                    end
                    if settings["Resolve"] then
                        if settings["AutoPredict"] then
                            calculation = Vector3.new(resolve(settings["SilentVictim"].Name).X * (mag * (ping * settings["AutoPrediction"])), resolve(settings["SilentVictim"].Name).Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), resolve(settings["SilentVictim"].Name).Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        else 
                            calculation = Vector3.new(resolve(settings["SilentVictim"].Name).X * (mag * (ping * settings["Prediction"])), resolve(settings["SilentVictim"].Name).Y * ((mag * (ping * settings["Prediction"]))/settings.offset), resolve(settings["SilentVictim"].Name).Z * (mag * (ping * settings["Prediction"])))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        end
                    end
                end
            end
            if not settings["Silent"] or not settings["SilentVictim"] then break end
        end
    end)
end

-- Antilock function: Done, Needs to check on it.
rs.Heartbeat:Connect(function()
    if settings["Antilock"] then
        local hrp = game.Players.LocalPlayer.Character.HumanoidRootPart
        local vel, cf = hrp.AssemblyLinearVelocity, hrp.CFrame
        if settings["AntiPosition"] == "Sky" then
            hrp.AssemblyLinearVelocity = Vector3.new(0,6e6,0)
            hrp.CFrame = cf * CFrame.Angles(0,math.rad(0.1),0)
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
        elseif settings["AntiPosition"] == "Ground" then
            hrp.AssemblyLinearVelocity = Vector3.new(0,-6e6,0)
            hrp.CFrame = cf * CFrame.Angles(0,math.rad(0.1),0)
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
        elseif settings["AntiPosition"] == "Troll" then
            hrp.AssemblyLinearVelocity = Vector3.new(0,0,math.random(-666,666))
            hrp.CFrame = cf * CFrame.Angles(0,0,math.rad(0.1))
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = Vector3.new(math.random(-666,666),0,0)
            hrp.CFrame = cf * CFrame.Angles(math.rad(0.1),0,0)
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
        elseif settings["AntiPosition"] == "Prediction" then
            hrp.AssemblyLinearVelocity = Vector3.new(0,0,0)
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
        end
    end
end)

-- Heartbeat functions:
rs.Heartbeat:Connect(function()
    -- Reload button resize: Done.
    if me.PlayerGui:FindFirstChild("gui"):FindFirstChild("mobile ppl"):FindFirstChild("rl") then
        me.PlayerGui:WaitForChild("gui")["mobile ppl"].rl.Size = UDim2.new(0,70,0,70)
    end
    -- Getting ping for auto prediction:
    value = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
    ping = tonumber(string.split(value, '(')[1])
    -- Auto Armour: Done.
    if settings["AutoArmour"] then
        fireclickdetector(armour.ClickDetector)
    end
    -- Auto Food: Still Fixing.
    if settings["AutoFood"] then
        for i,food in basket do
            fireclickdetector(food.ClickDetector)
        end
    end
    if settings["AutoTactical"] then
        fireclickdetector(tac.ClickDetector)
    end
    -- Update Dot: Still Fixing.
    if settings["Dot"] then
        local pos, onscreen = cc:WorldToViewportPoint(game.Players[settings["Target"]].Character[settings["Aimpart"]].Position)
        if onscreen and game.Players:FindFirstChild(settings["Target"]) then
            dot.Visible = true
            dot.Position = Vector2.new(pos.X, pos.Y)
        else
            dot.Visible = false
        end
    else
        dot.Visible = false
    end
    
    
    
    -- Aimlock: Not done scripting...
    -- ...
end)

rs.Heartbeat:Connect(function()
    if settings["Strafe"]["Status"] then
        me.Character.HumanoidRootPart.CFrame = game.Players[settings["Target"]].Character.HumanoidRootPart.CFrame * CFrame.Angles(0,math.rad(settings["Strafe"]["Speed"]),0) * CFrame.new(0,settings["Strafe"]["Height"],settings["Strafe"]["Distance"])
    end
end)


    -- Aimlock: Not done scripting...
    if settings["Aimlock"] then
        local calculation, result
        local victim, old = game.Players[settings["Target"]], mt.__namecall
        local ALV, mag = victim.Character[settings["Aimpart"]].AssemblyLinearVelocity, victim.Character.Humanoid.MoveDirection.magnitude
        mt.__namecall = newcclosure(function(Self, ...)
            local Args = {...}
            local method = tostring(getnamecallmethod())
            
            if method == "FireServer" and Self.Name == "MAINEVENT" then
                if tostring(Args[1]) == "MOUSE" and victim then
                    if settings["AutoPredict"] then
                        calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), 0, ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                    else
                        calculation = Vector3.new(ALV.X * settings["Prediction"], 0, ALV.Z * settings["Prediction"])
                    end
                    
                    result = Vector3.new(victim.Character[settings["Aimpart"]].Position + calculation)
                    Args[2] = result
                else
                    print("smth went wrong with the aimlock.")
                    return old(Self, unpack(Args))
                end
            end
            
            return old(Self, unpack(Args))
        end)
    end

--\\--| Whitelist Stuff |--//--
-- Done and working!
me.Chatted:Connect(function(message)
    local cmd, ShortName, name
    local words = string.split(message, " ")
    for i,v in words do if i == 1 then cmd = v end if i == 2 then ShortName = v end end
    if ShortName ~= nil then
        name = getuser(ShortName)
    end
    if cmd == ".ws" then
        if not table.find(settings["whitelist"],name) then
            table.insert(settings["whitelist"],name)
            Notify("Whitelist Notification",name.." has been whitelisted!", 1)
        else
            Notify("Already Whitelisted",name.." was already whitelisted...", 1)
        end
    elseif cmd == ".unws" then
        if table.find(settings["whitelist"],name) then
            local i = table.find(settings["whitelist"],name)
            table.remove(settings["whitelist"],i)
            Notify("Un-whitelist Notification",name.." has been un-whitelisted!", 1)
        else
            Notify("Person Not Found",name.." was already unwhitelisted!", 1)
        end
    end
end)

local lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()
local window = lib:Load(game.Players.LocalPlayer.DisplayName, "Default")
local Target = lib.newTab("Target", "")
local Main = lib.newTab("Main", "")
local Misc = lib.newTab("Misc", "")
local Setting = lib.newTab("Setting", "")
local Credits = lib.newTab("Credits", "")


local btnGui = Instance.new("ScreenGui")
btnGui.Name = "ButtonHandler"
btnGui.Parent = game.CoreGui
btnGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

--// Target Stuff:
Target.newInput("Username", "Enter a username to be your target.", function(input)
    settings["Target"] = getuser(input)
end)
Target.newToggle("Lock Dot", "Creates dot on the target.", false, function(bool)
    settings["Dot"] = bool
end)
Target.newToggle("View", "Views the current target.", false, function(bool)
    settings["view"] = bool
    local old = me.Character.Humanoid
    task.wait()
    if settings["view"] then
        if game.Players[settings["Target"]] and game.Players[settings["Target"]].Character.Humanoid then
            cc.CameraSubject = game.Players[settings["Target"]].Character.Humanoid
        else
            cc.CameraSubject = old
        end
    else
        cc.CameraSubject = old
    end
end)
Target.newToggle("Aimlock", "Aimlocks without having to aim.", false, function(bool)
    settings["Aimlock"] = bool
end)
Target.newToggle("Target Strafe", "Randomly teleports you near the target.", false, function(bool)
    settings["Strafe"]["Status"] = bool
end)

--// Main stuff:
Main.newToggle("Auto Prediction","Turns auto prediction on/off", true, function(bool)
    settings["AutoPredict"] = bool
end)
Main.newToggle("Smooth Camlock","Makes the camlock smooth.", true, function(bool)
    settings["Smoothing"] = bool
end)
Main.newToggle("Resolver","Antilock resolver.", false, function(bool)
    settings["Resolver"] = bool
end)
Main.newToggle("Scriptable Camera", "Makes your camera scriptable when lock is on. (helps with camlock a lot)", false, function(bool)
    settings["Scriptable"] = bool
end)
Main.newToggle("Anti-lock","Turns anti-lock on/off.", false, function(bool)
    settings["Antilock"] = bool
end)
Main.newToggle("Auto Stomp","Auto stomps whenever you walk on someone's body.", false, function(bool)
    settings["AutoStomp"] = bool
    if settings["AutoStomp"] then
        autostomp()
    end
end)
Main.newToggle("Auto Food","Spawns you with food and rebuys when eaten.", true, function(bool)
    settings["AutoFood"] = bool
end)
Main.newToggle("Auto Tactical","Auto buys tactical shotgun when not in inventory.", false, function(bool)
    settings["AutoTactical"] = bool
end)
Main.newButton("Custom Macro View", "Fixes the macro button and makes it third person.", function()
    local LS = game.Players.LocalPlayer.PlayerScripts.Macro
    for i, v in pairs(getsenv(LS)) do
        for _, cons in getconstants(getsenv(LS).inout) do
            setconstant(getsenv(LS).inout, 1, 8)
        end
    end
end)

--// Misc Stuff:
Misc.newButton("Lock Button", "Creates a lock button", function()
    if not game:GetService("CoreGui").ButtonHandler:FindFirstChild("L") then
        ButtonsModule.lockButton("L")
    end
    
    lockbutton = game:GetService("CoreGui").ButtonHandler.L
    
    lockbutton.MouseButton1Click:Connect(function()
        local silentbuttoncheck = game.CoreGui:FindFirstChild("ButtonHandler"):FindFirstChild("S")
        if game.Players:FindFirstChild(settings["Target"]) then
            if not settings["Camlock"] then
                settings["Camlock"] = true
                camlock()
                Notify("Lock Notif", "  Target: "..settings["Target"], 1)
                settings["Silent"] = false
                lockbutton.Text = "Unlock"
                silentbutton.Text = "Silent lock"
            else
                settings["Camlock"] = false
                lockbutton.Text = "Lock"
            end
        else
            settings["Camlock"] = false
            lockbutton.Text = "Lock"
        end
    end)
    Notify("Button Notif", "Lock button has been successfully created!", 1)
end)
Misc.newButton("Silent Button", "Creates a silent button", function()
    if not game:GetService("CoreGui").ButtonHandler:FindFirstChild("S") then
        ButtonsModule.silentButton("S")
    end
    
    silentbutton = game:GetService("CoreGui").ButtonHandler.S
    
    silentbutton.MouseButton1Click:Connect(function()
        local lockbutton = game.CoreGui:FindFirstChild("ButtonHandler"):FindFirstChild("L")
        if not settings["Silent"] then
            settings["Silent"] = true
            silentlock()
            settings["Camlock"] = false
            silentbutton.Text = "Unlock"
            lockbutton.Text = "Lock"
        else
            settings["Silent"] = false
            silentbutton.Text = "Silent lock"
        end
    end)
    Notify("Button Notif", "Silent button has been successfully created!", 1)
end)
Misc.newButton("Armour Button", "Creates a armour button", function()
    if not game:GetService("CoreGui").ButtonHandler:FindFirstChild("A") then
        ButtonsModule.armourButton("A")
    end
    
    armourbutton = game:GetService("CoreGui").ButtonHandler.A
    
    armourbutton.MouseButton1Click:Connect(function()
        if not settings["AutoArmour"] then
            settings["AutoArmour"] = true
            armourbutton.BackgroundColor3 = Color3.fromRGB(215,40,20)
            armourbutton.Text = "Stop Auto Armour"
        else
            settings["AutoArmour"] = false
            armourbutton.BackgroundColor3 = Color3.fromRGB(5,190,10)
            armourbutton.Text = "Auto Armour"
        end
    end)
    Notify("Button Notif", "Armour button has been successfully created!", 1)
end)

--// Settings stuff:
Setting.newDropdown("Anti-lock Position", "Adjusts the position of the anti-lock.", { "Sky", "Ground", "Troll", "Prediction" }, function(picked)
    settings["AntiPosition"] = picked
end)
Setting.newDropdown("Aimpart", "Adjusts the part of the camlock.", settings["Aimparts"], function(picked)
    settings["Aimpart"] = picked
end)
Setting.newDropdown("Resolve Type", "Adjusts the anti-lock resolver type.", { "Recalculate velocity", "Zero" }, function(picked)
    settings["ResolverType"] = picked
end)
Setting.newInput("Aimlock Prediction Amount", "Adjusts the aimlock prediction.", function(inp)
    settings["AimlockPrediction"] = tonumber(inp)
end)
Setting.newInput("Auto Prediction Amount", "Adjusts the ping-based prediction (MUST BE 0.00number).", function(inp)
    settings["AutoPrediction"] = tonumber(inp)
end)
Setting.newInput("Prediction Amount", "Adjusts the prediction.", function(inp)
    settings["Prediction"] = tonumber(inp)
end)
Setting.newInput("Smoothening Amount", "Adjusts the smoothening amount.", function(inp)
    settings["SmoothingAmount"] = tonumber(inp)
end)
Setting.newInput("Auto Stomp Delay", "Adjusts the auto stomp delay.", function(inp)
    settings["AutoStompDelay"] = tonumber(inp)
end)