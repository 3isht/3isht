repeat task.wait() until game:IsLoaded()

for i,v in next, debug do
    if not getgenv()[i] then
        getgenv()[i] = v
    end
end

getgenv().settings = {
    ["Aimlock"] = false, -- Aimlock toggle.
    ["AimlockPrediction"] = 5.3, -- Aimlock prediction
    ["Aimpart"] = "HumanoidRootPart",-- Aimpart for lock --\\ Head | UpperTorso | LowerTorso | etc... //-- 
    ["Aimparts"] = { "Head", "UpperTorso","LowerTorso", "HumanoidRootPart" },
    ["AntiPosition"] = "Sky", -- Sky|Ground|Prediction
    -- \\ Locates it up in the Sky | Underground | Trolls The Locker | Disables the locker's prediction //
    ["Antilock"] = false, -- Anti Lock toggle.
    ["AutoArmour"] = false, -- Auto Buys Armour
    ["AutoFood"] = true, -- Auto Buys Food toggle.
    ["AutoPredict"] = true, -- Automatically predicts correctly (HIGHLY RECOMMENDED).
    ["AutoPrediction"] = 0.001788, -- Automatic camlock prediction based on ping (RECOMMENDED).
    ["AutoStomp"] = false, -- Auto Stomps toggle.
    ["AutoStompDelay"] = 0, -- Auto Stomp Delay \\ 0 = no delay // (Seconds).
    ["Camlock"] = false, -- CamLock toggle.
    ["Dot"] = false, -- Creates a dot on "Target".
    ["Fling"] = false, -- Boolean that locates whether the exploit user is flinging someone or not.
    ["FlingTargets"] = {}, -- Add whoever you want here for them to get flung.
    ["GameId"] = game.PlaceId, -- Gets the game's ID
    ["KnockCheck"] = true, -- Checks if the person targeted is knoked or nah.
    ["Prediction"] = 0.2805, -- Manual camlock prediction.
    ["Resolver"] = false, -- Anti-Lock Resolver.
    ["ResolverType"] = "Recalculate velocity", -- Recalculate velocity|Move Direction|Zero|Horizontal
    ["Scriptable"] = false, -- Maybe a better camlock update? üó£üî•‚ÄºÔ∏è
    ["Silent"] = false, -- Silent CamLock toggle.
    ["Smoothing"] = true, -- Smoothes camlock camera movement.
    ["SmoothingAmount"] = 0.422, -- Smooth amount << Higher = Slower >>
    ["Target"] = nil, -- Person targeted.
    ["Strafe"] = { -- Target Strafe basically.
        ["Status"] = false,
        ["Speed"] = .2,
        ["Height"] = 5,
        ["Distance"] = 20
    },
    ["SilentVictim"] = "", -- Silent CamLock Target.
    ["view"] = false, -- View toggle.
    ["whitelist"] = {}, -- Whitelisted players.
    ["AutoTactical"] = false, -- Auto buys tactical.
    ["RefreshRate"] = 43, -- Resolver refresh rate.
    ["ResolvedVelocity"] = Vector3.new(0,0,0) -- Kind of a fix to the resolver for no working in the functions.
}
local ButtonsModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/3isht/3isht/master/ModuleTest.lua"))()
local me = game.Players.LocalPlayer
local rs = game:GetService("RunService")
local cc = game.workspace.CurrentCamera
settings.offset = 2.77
local value, ping, armour, lockbutton, silentbutton, armourbutton, basket, tac, usp, sg, WSplayers, oldPos, oldTick

print("Auto prediction\n0.001812\nSmoothening amount\n0.422")
print("Auto prediction\n0.001769\nSmoothening amount\n0.422")


local dot = Drawing.new("Circle")
dot.Visible = false
dot.Filled = true
dot.Thickness = 1
dot.Radius = 3
dot.Color = Color3.fromRGB(175,30,175)

--// ChatSpy \\--
--loadstring(game:HttpGet("https://raw.githubusercontent.com/3isht/3isht/master/chatspy"))()

function getplayersfolder()
    local playersFolder
    for i,v in game.workspace:GetDescendants() do
        if v.Name == me.Name then
            playersFolder = v.Parent
            return playersFolder
        end
    end
end

function autostomp()
    while task.wait(settings["AutoStompDelay"]) do
        game:GetService("ReplicatedStorage"):WaitForChild("MAINEVENT"):FireServer("STOMP")
        if not settings["AutoStomp"] then break end
    end
end

local getarmour = function()
    for _, child in game.workspace:GetDescendants() do
        if child.Name:lower() == "[high-medium armor]" and child:FindFirstChildWhichIsA("ClickDetector") then
            return child end
        if child.Name:lower() == "[medium armor]" and child:FindFirstChildWhichIsA("ClickDetector") then
            return child end
    end
end
local gettac = function()
    for _,child in game.workspace:GetDescendants() do
        if child.Name == "[Tactical Shotgun]" and child:FindFirstChildWhichIsA("ClickDetector") then
            return child end
    end
end

-- Returns a table.
function getfood()
    local f = {}
    local succ, err = pcall(function()
        for _, v in next, game.workspace:GetDescendants() do
            if v.Name:lower() == "[pizza]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
            if v.Name:lower() == "[burger]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
            if v.Name:lower() == "[donut]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
            if v.Name:lower() == "[popcorn]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
            if v.Name:lower() == "[chicken]" and v:FindFirstChildWhichIsA("ClickDetector") then
                table.insert(f, v)
            end
        end
    end)
    if err then
        print("Something errored in getfood() : "..err)
    end
    return f
end

-- Returns Player Full Form.
function getnear()
    local max = math.huge
    local distance = nil
    local nearest = nil
    for i, player in game.Players:GetChildren() do
        if player.Name ~= me.Name and not WSplayers[player.Name]:GetAttribute("Knocked") and not table.find(settings["whitelist"], player.Name) then
            distance = (me.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).magnitude
            if distance < max then
                max = distance
                nearest = player
            end
        end
    end
    return nearest
end

-- Returns a string (username).
function getuser(inp)
    if inp == " " or inp == "" then return end
    local low = inp:lower()
    for _,v in next, game.Players:GetChildren() do
        if string.sub(v.Name:lower(),1,#low) == low or string.sub(v.DisplayName:lower(),1,#low) == low and v.Name ~= me.Name then
            return v.Name
        end
    end
end

function strafe(name)
    local target = game.Players[name]
    local hum = me.Character.HumanoidRootPart
    local angle = math.pi / settings["Strafe"]["Speed"]
    
    coroutine.wrap(function()
        while task.wait() do
            if settings["Strafe"]["Status"] == false then
                break end
            
            local ang = tick() * angle
            local center = target.Character.HumanoidRootPart.Position
            local x,y,z
            x = center.X + settings["Strafe"]["Distance"] * math.cos(ang)
            y = center.Y + settings["Strafe"]["Height"]
            z = center.Z + settings["Strafe"]["Distance"] * math.sin(ang)
            
            hum.CFrame = CFrame.new(Vector3.new(x,y,z))
            hum.CFrame = CFrame.new(hum.Position, center)
        end
    end)()
end

function Notify(name,desc,dur)
    game.StarterGui:SetCore("SendNotification", {
        Title = name,
        Text = desc,
        Duration = dur
    })
end
function isKnocked(name)
    local person = WSplayers[name]
    local knocked = person:GetAttribute("Knocked") or person:GetAttribute("K.O") or nil
    if knocked == nil then return false end
    if not knocked then return false else return true end
end
function resolve(name)
    local noob = game.Players[name]
    if settings["ResolverType"] == "Recalculate velocity" then
        oldPos = noob.Character.HumanoidRootPart.Position
        oldTick = tick()
        task.wait()
        local newPos = noob.Character.HumanoidRootPart.Position
        local newTick = tick()
        local Time = newTick - oldTick
        local newVel = (newPos - oldPos) / Time
        print(tick()-oldTick.. " || Refresh rate: ".. 1/settings["RefreshRate"])
        if tick() - oldTick >= 1 / settings["RefreshRate"] then
            oldTick, oldPos = newTick, newPos
        end
        return newVel
    elseif settings["ResolverType"] == "Horizontal" then
        local oldVel = noob.Character.HumanoidRootPart.AssemblyLinearVelocity
        local newVel = Vector3.new(oldVel.X,0,oldVel.Z)
        return newVel
    elseif settings["ResolverType"] == "Zero" then
        return Vector3.new(0,0,0)
    end
end

local fling = function(TargetName)
    local TargetPlayer = game.Players[TargetName]
    local Character = me.Character
    local Humanoid = Character and Character:FindFirstChildOfClass("Humanoid")
    local RootPart = Humanoid and Humanoid.RootPart
    
    local TCharacter = TargetPlayer.Character
    local THumanoid
    local TRootPart
    local THead
    local Accessory
    local Handle
    
    if TCharacter:FindFirstChildOfClass("Humanoid") then
        THumanoid = TCharacter:FindFirstChildOfClass("Humanoid")
    end
    if THumanoid and THumanoid.RootPart then
        TRootPart = THumanoid.RootPart
    end
    if TCharacter:FindFirstChild("Head") then
        THead = TCharacter.Head
    end
    if TCharacter:FindFirstChildOfClass("Accessory") then
        Accessory = TCharacter:FindFirstChildOfClass("Accessory")
    end
    if Accessory and Accessory:FindFirstChild("Handle") then
        Handle = Accessory.Handle
    end
    
    if Character and Humanoid and RootPart then
        if RootPart.Velocity.Magnitude < 50 then
            getgenv().POS = RootPart.CFrame
        end
        if THumanoid and THumanoid.Sit then
            return Notify("Error Occurred", "Target is sitting", 1) -- u can remove dis part if u want lol
        end
        if THead then
            workspace.CurrentCamera.CameraSubject = THead
        elseif not THead and Handle then
            workspace.CurrentCamera.CameraSubject = Handle
        elseif THumanoid and TRootPart then
            workspace.CurrentCamera.CameraSubject = THumanoid
        end
        if not TCharacter:FindFirstChildWhichIsA("BasePart") then
            return
        end
        
        local FPos = function(BasePart, Pos, Ang)
            RootPart.CFrame = CFrame.new(BasePart.Position) * Pos * Ang
            Character:SetPrimaryPartCFrame(CFrame.new(BasePart.Position) * Pos * Ang)
            RootPart.Velocity = Vector3.new(9e7, 9e7 * 10, 9e7)
            RootPart.RotVelocity = Vector3.new(9e8, 9e8, 9e8)
        end
        
        local SFBasePart = function(BasePart)
            local TimeToWait = 3
            local Time = tick()
            local Angle = 0
            
            repeat
                if RootPart and THumanoid then
                    if BasePart.Velocity.Magnitude < 50 then
                        Angle = Angle + 100
                        
                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle),0 ,0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(2.25, 1.5, -2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(-2.25, -1.5, 2.25) + THumanoid.MoveDirection * BasePart.Velocity.Magnitude / 1.25, CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, 1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, -1.5, 0) + THumanoid.MoveDirection,CFrame.Angles(math.rad(Angle), 0, 0))
                        task.wait()
                    else
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                        
                        FPos(BasePart, CFrame.new(0, -1.5, -THumanoid.WalkSpeed), CFrame.Angles(0, 0, 0))
                        task.wait()
            
                        FPos(BasePart, CFrame.new(0, 1.5, THumanoid.WalkSpeed), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
                                    
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
            
                        FPos(BasePart, CFrame.new(0, -1.5, -TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(0, 0, 0))
                        task.wait()
            
                        FPos(BasePart, CFrame.new(0, 1.5, TRootPart.Velocity.Magnitude / 1.25), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
            
                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(math.rad(90), 0, 0))
                        task.wait()
            
                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
            
                        FPos(BasePart, CFrame.new(0, -1.5 ,0), CFrame.Angles(math.rad(-90), 0, 0))
                        task.wait()
            
                        FPos(BasePart, CFrame.new(0, -1.5, 0), CFrame.Angles(0, 0, 0))
                        task.wait()
                    end
                else
                    break
                end
            until BasePart.Velocity.Magnitude > 500 or BasePart.Parent ~= TargetPlayer.Character or TargetPlayer.Parent ~= Players or not TargetPlayer.Character == TCharacter or THumanoid.Sit or Humanoid.Health <= 0 or tick() > Time + TimeToWait
        end
        
        workspace.FallenPartsDestroyHeight = 0/0
        
        local BV = Instance.new("BodyVelocity")
        BV.Name = "spox's vel"
        BV.Parent = RootPart
        BV.Velocity = Vector3.new(9e8, 9e8, 9e8)
        BV.MaxForce = Vector3.new(1/0, 1/0, 1/0)
        
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
        
        if TRootPart and THead then
            if (TRootPart.CFrame.p - THead.CFrame.p).Magnitude > 5 then
                SFBasePart(THead)
            else
                SFBasePart(TRootPart)
            end
        elseif TRootPart and not THead then
            SFBasePart(TRootPart)
        elseif not TRootPart and THead then
            SFBasePart(THead)
        elseif not TRootPart and not THead and Accessory and Handle then
            SFBasePart(Handle)
        else
            return Notify("Error Occurred", "Target is missing everything", 1)
        end
            
        BV:Destroy()
        Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, true)
        workspace.CurrentCamera.CameraSubject = Humanoid
        
        repeat
            RootPart.CFrame = getgenv().POS * CFrame.new(0, .5, 0)
            Character:SetPrimaryPartCFrame(getgenv().POS * CFrame.new(0, .5, 0))
            Humanoid:ChangeState("GettingUp")
            table.foreach(Character:GetChildren(), function(_, x)
                if x:IsA("BasePart") then
                    x.Velocity, x.RotVelocity = Vector3.new(), Vector3.new()
                end
            end)
            task.wait()
        until (RootPart.Position - getgenv().POS.p).Magnitude < 25
        workspace.FallenPartsDestroyHeight = getgenv().FPDH
    else
        return Notify("Error Occurred", "Random error", 1)
    end
end

function camlock()
    task.spawn(function()
        local noob = game.Players[settings["Target"]]
        local calculation, mag, goal
        while task.wait() do
            if settings["KnockCheck"] then
                if settings["Camlock"] and settings["Target"] ~= me.Name and noob and isKnocked(noob.Name) == false then
                    local ALV = noob.Character[settings["Aimpart"]].AssemblyLinearVelocity
                    if settings["Smoothing"] then
                        if settings["AutoPredict"] then
                            mag = (noob.Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        else 
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset) ,ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        end
                        if settings["Resolver"] then
                            settings["ResolvedVelocity"] = resolve(settings["Target"])
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(settings["ResolvedVelocity"]*Vector3.new((mag * (ping * settings["AutoPrediction"])),((mag * (ping * settings["AutoPrediction"]))/settings.offset),(mag * (ping * settings["AutoPrediction"]))))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            else 
                                calculation = Vector3.new(settings["ResolvedVelocity"].X *(settings["Prediction"]), settings["ResolvedVelocity"].Y *(settings["Prediction"]/settings.offset), settings["ResolvedVelocity"].Z *(settings["Prediction"]))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            end
                        end
                    else
                        if settings["AutoPredict"] then
                            mag = (noob.Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        else 
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]),noob.Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        end
                        if settings["Resolver"] then
                            settings["ResolvedVelocity"] = resolve(settings["Target"])
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(settings["ResolvedVelocity"].X * (mag * (ping * settings["AutoPrediction"])), settings["ResolvedVelocity"].Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), settings["ResolvedVelocity"].Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            else 
                                calculation = Vector3.new(settings["ResolvedVelocity"].X *(settings["Prediction"]), settings["ResolvedVelocity"].Y *(settings["Prediction"]/settings.offset), settings["ResolvedVelocity"].Z *(settings["Prediction"]))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            end
                        end
                    end
                end
            else
                if settings["Camlock"] and settings["Target"] ~= me.Name then
                    local ALV = noob.Character[settings["Aimpart"]].AssemblyLinearVelocity
                    if settings["Smoothing"] then
                        if settings["AutoPredict"] then
                            mag = (noob.Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        else 
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset) ,ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        end
                        if settings["Resolver"] then
                            settings["ResolvedVelocity"] = resolve(settings["Target"])
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(settings["ResolvedVelocity"].X * (mag * (ping * settings["AutoPrediction"])), settings["ResolvedVelocity"].Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), settings["ResolvedVelocity"].Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            else 
                                calculation = Vector3.new(settings["ResolvedVelocity"].X *(settings["Prediction"]), settings["ResolvedVelocity"].Y *(settings["Prediction"]/settings.offset), settings["ResolvedVelocity"].Z *(settings["Prediction"]))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            end
                        end
                    else
                        if settings["AutoPredict"] then
                            mag = (noob.Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), noob.Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        else 
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]),noob.Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        end
                        if settings["Resolver"] then
                            settings["ResolvedVelocity"] = resolve(settings["Target"])
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(settings["ResolvedVelocity"].X * (mag * (ping * settings["AutoPrediction"])), settings["ResolvedVelocity"].Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), settings["ResolvedVelocity"].Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            else 
                                calculation = Vector3.new(settings["ResolvedVelocity"].X *(settings["Prediction"]), settings["ResolvedVelocity"].Y *(settings["Prediction"]/settings.offset), settings["ResolvedVelocity"].Z *(settings["Prediction"]))
                                goal = CFrame.new(cc.CFrame.p, (noob.Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            end
                        end
                    end
                end
            end
            if not settings["Camlock"] or not game.Players[settings["Target"]] then break end
        end
    end)
end

function silentlock()
    task.spawn(function()
        settings["SilentVictim"] = getnear()
        local calculation, mag, goal
        local type = cc.CameraType
        task.wait()
        if settings["Scriptable"] then cc.CameraType = Enum.CameraType.Scriptable end
        Notify("Silent Notif", "  Silent: "..settings["SilentVictim"].Name, 1)
        while task.wait() do
            if settings["KnockCheck"] then
                if settings["Silent"] and settings["SilentVictim"] and not table.find(settings["whitelist"], settings["SilentVictim"].Name) and isKnocked(settings["SilentVictim"].Name) == false then
                    local ALV = settings["SilentVictim"].Character[settings["Aimpart"]].AssemblyLinearVelocity
                    if settings["Smoothing"] then
                        if settings["AutoPredict"] then
                            mag = (settings["SilentVictim"].Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        else
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        end
                        if settings["Resolver"] then
                            settings["ResolvedVelocity"] = resolve(settings["SilentVictim"].Name)
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(settings["ResolvedVelocity"].X * (mag * (ping * settings["AutoPrediction"])), settings["ResolvedVelocity"].Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), settings["ResolvedVelocity"].Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            else 
                                calculation = Vector3.new(settings["ResolvedVelocity"].X *(settings["Prediction"]), settings["ResolvedVelocity"].Y *(settings["Prediction"]/settings.offset), settings["ResolvedVelocity"].Z *(settings["Prediction"]))
                                goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            end
                        end
                    else
                        if settings["AutoPredict"] then
                            mag = (settings["SilentVictim"].Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        else
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        end
                        if settings["Resolver"] then
                            settings["ResolvedVelocity"] = resolve(settings["SilentVictim"].Name)
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(settings["ResolvedVelocity"].X * (mag * (ping * settings["AutoPrediction"])), settings["ResolvedVelocity"].Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), settings["ResolvedVelocity"].Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            else 
                                calculation = Vector3.new(settings["ResolvedVelocity"].X *(settings["Prediction"]), settings["ResolvedVelocity"].Y *(settings["Prediction"]/settings.offset), settings["ResolvedVelocity"].Z *(settings["Prediction"]))
                                goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            end
                        end
                    end
                end
            else
                if settings["Silent"] and settings["SilentVictim"] and not table.find(settings["whitelist"], settings["SilentVictim"].Name) then
                    local ALV = settings["SilentVictim"].Character[settings["Aimpart"]].AssemblyLinearVelocity
                    if settings["Smoothing"] then
                        if settings["AutoPredict"] then
                            mag = (settings["SilentVictim"].Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        else
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                        end
                        if settings["Resolver"] then
                            settings["ResolvedVelocity"] = resolve(settings["SilentVictim"].Name)
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(settings["ResolvedVelocity"].X * (mag * (ping * settings["AutoPrediction"])), settings["ResolvedVelocity"].Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), settings["ResolvedVelocity"].Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            else 
                                calculation = Vector3.new(settings["ResolvedVelocity"].X *(settings["Prediction"]), settings["ResolvedVelocity"].Y *(settings["Prediction"]/settings.offset), settings["ResolvedVelocity"].Z *(settings["Prediction"]))
                                goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = cc.CFrame:Lerp(goal, settings["SmoothingAmount"], Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut)
                            end
                        end
                    else
                        if settings["AutoPredict"] then
                            mag = (settings["SilentVictim"].Character.Humanoid.MoveDirection).magnitude
                            
                            calculation = Vector3.new(ALV.X * (mag * (ping * settings["AutoPrediction"])), settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), ALV.Z * (mag * (ping * settings["AutoPrediction"])))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        else
                            calculation = Vector3.new(ALV.X * (settings["Prediction"]),settings["SilentVictim"].Character["RightFoot"].AssemblyLinearVelocity.Y * (settings["Prediction"] / settings.offset),ALV.Z * (settings["Prediction"]))
                            goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                            cc.CFrame = goal
                        end
                        if settings["Resolver"] then
                            settings["ResolvedVelocity"] = resolve(settings["SilentVictim"].Name)
                            if settings["AutoPredict"] then
                                calculation = Vector3.new(settings["ResolvedVelocity"].X * (mag * (ping * settings["AutoPrediction"])), settings["ResolvedVelocity"].Y * ((mag * (ping * settings["AutoPrediction"]))/settings.offset), settings["ResolvedVelocity"].Z * (mag * (ping * settings["AutoPrediction"])))
                                goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            else 
                                calculation = Vector3.new(settings["ResolvedVelocity"].X *(settings["Prediction"]), settings["ResolvedVelocity"].Y *(settings["Prediction"]/settings.offset), settings["ResolvedVelocity"].Z *(settings["Prediction"]))
                                goal = CFrame.new(cc.CFrame.p, (settings["SilentVictim"].Character[settings["Aimpart"]].Position + calculation))
                                cc.CFrame = goal
                            end
                        end
                    end
                end
            end
            if not settings["Silent"] or not settings["SilentVictim"] then break end
        end
    end)
end


basket = getfood()
armour = getarmour()
tac = gettac()
WSplayers = getplayersfolder()

-- Antilock function: Done, Needs to check on it.
rs.Heartbeat:Connect(function()
    if settings["Antilock"] then
        local hrp = game.Players.LocalPlayer.Character.HumanoidRootPart
        local vel, cf = hrp.AssemblyLinearVelocity, hrp.CFrame
        
        
        if settings["AntiPosition"] == "Sky" then
            hrp.AssemblyLinearVelocity = Vector3.new(0,6e6,0)
            hrp.CFrame = cf * CFrame.Angles(0,math.rad(0.1),0)
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
        elseif settings["AntiPosition"] == "Ground" then
            hrp.AssemblyLinearVelocity = Vector3.new(0,-6e6,0)
            hrp.CFrame = cf * CFrame.Angles(0,math.rad(0.1),0)
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
        elseif settings["AntiPosition"] == "Troll" then
            hrp.AssemblyLinearVelocity = Vector3.new(math.random(-800,800), math.random(-250,250), math.random(-800,800))
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
        elseif settings["AntiPosition"] == "Prediction" then
            hrp.AssemblyLinearVelocity = Vector3.new(0,0,0)
            rs.RenderStepped:Wait()
            hrp.AssemblyLinearVelocity = vel
        end
    end
end)

-- Heartbeat functions:
rs.Heartbeat:Connect(function()
    -- Reload button resize: Done.
    if me.PlayerGui:FindFirstChild("gui"):FindFirstChild("mobile ppl"):FindFirstChild("rl") then
        me.PlayerGui:WaitForChild("gui")["mobile ppl"].rl.Size = UDim2.new(0,70,0,70)
    end
    -- Getting ping for auto prediction:
    value = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValueString()
    ping = tonumber(string.split(value, '(')[1])
    -- Auto Armour: Done.
    if settings["AutoArmour"] then
        fireclickdetector(armour.ClickDetector)
    end
    -- Auto Food: Still Fixing.
    if settings["AutoFood"] then
        for i,food in basket do
            fireclickdetector(food.ClickDetector)
        end
    end
    if settings["AutoTactical"] then
        fireclickdetector(tac.ClickDetector)
    end
    -- Update Dot: Still Fixing.
    if settings["Dot"] and game.Players[settings["Target"]] then
        local pos, onscreen = cc:WorldToViewportPoint(game.Players[settings["Target"]].Character[settings["Aimpart"]].Position)
        if onscreen then
            dot.Visible = true
            dot.Position = Vector2.new(pos.X, pos.Y)
        else
            dot.Visible = false
        end
    else
        dot.Visible = false
    end
end)

--\\--| Whitelist Stuff |--//--
-- Done and working!
me.Chatted:Connect(function(message)
    if not message then return end
    
    local cmd, ShortName, name
    local words = string.split(message, " ")
    
    for i,v in words do if i == 1 then cmd = v end if i == 2 then ShortName = v end end
    
    if ShortName ~= nil then
        name = getuser(ShortName)
    end
    
    if cmd == ".ws" then
        if not table.find(settings["whitelist"],name) then
            table.insert(settings["whitelist"],name)
            Notify("Whitelist Notification",name.." has been whitelisted!", 1)
        else
            Notify("Already Whitelisted",name.." was already whitelisted...", 1)
        end
    elseif cmd == ".unws" then
        if table.find(settings["whitelist"],name) then
            local i = table.find(settings["whitelist"],name)
            table.remove(settings["whitelist"],i)
            Notify("Un-whitelist Notification",name.." has been un-whitelisted!", 1)
        else
            Notify("Person Not Found",name.." was already unwhitelisted!", 1)
        end
    elseif cmd == ".fadd" then
        if not table.find(settings["FlingTargets"],name) then
            table.insert(settings["FlingTargets"],name)
            Notify("Fling Notif", name.." has been added to fling targets.", 1)
        else Notify("Fling Notif", name.." was already in fling targets.", 1) end
    elseif cmd == ".fremove" then
        if table.find(settings["FlingTargets"],name) then
            local i = table.find(settings["FlingTargets"],name)
            table.remove(settings["FlingTargets"],i)
            Notify("Fling Notif", name.." has been removed from fling targets.", 1)
        else Notify("Fling Notif", name.." was not in the fling targets.", 1) end
    elseif cmd == ".fling" then
        --[[
        table.insert(settings["FlingTargets"],name)
        local i = table.find(settings["FlingTargets"],name)
        table.remove(settings["FlingTargets"],i)
        ]]
        for _, v in settings["FlingTargets"] do
            fling(v)
        end
    end
end)

local lib = loadstring(game:HttpGet("https://raw.githubusercontent.com/AZYsGithub/DrRay-UI-Library/main/DrRay.lua"))()
local window = lib:Load(game.Players.LocalPlayer.DisplayName, "Default")
local Target = lib.newTab("Target", "")
local Main = lib.newTab("Main", "")
local Misc = lib.newTab("Misc", "")
local Setting = lib.newTab("Setting", "")
local Credits = lib.newTab("Credits", "")


local btnGui = Instance.new("ScreenGui")
btnGui.Name = "ButtonHandler"
btnGui.Parent = game.CoreGui
btnGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

--// Target Stuff:
Target.newInput("Username", "Enter a username to be your target.", function(input)
    settings["Target"] = getuser(input)
end)
Target.newToggle("Lock Dot", "Creates dot on the target.", false, function(bool)
    settings["Dot"] = bool
end)
Target.newToggle("View", "Views the current target.", false, function(bool)
    settings["view"] = bool
    local old = me.Character.Humanoid
    task.wait()
    if settings["view"] then
        if game.Players[settings["Target"]] and game.Players[settings["Target"]].Character.Humanoid then
            cc.CameraSubject = game.Players[settings["Target"]].Character.Humanoid
        else
            cc.CameraSubject = old
        end
    else
        cc.CameraSubject = old
    end
end)
Target.newToggle("Aimlock", "Aimlocks without having to aim.", false, function(bool)
    settings["Aimlock"] = bool
end)
Target.newToggle("Target Strafe", "Randomly teleports you near the target.", false, function(bool)
    settings["Strafe"]["Status"] = bool
    if settings["Strafe"]["Status"] then
        strafe(settings["Target"])
    end
end)
Target.newInput("Strafe Speed", "Target strafe's speed", function(inp)
    settings["Strafe"]["Speed"] = tonumber(inp)
end)
Target.newInput("Strafe Height", "Target strafe's height", function(inp)
    settings["Strafe"]["Height"] = tonumber(inp)
end)
Target.newInput("Strafe Distance", "Target strafe's distance", function(inp)
    settings["Strafe"]["Distance"] = tonumber(inp)
end)

--// Main stuff:
Main.newToggle("Auto Prediction","Turns auto prediction on/off", true, function(bool)
    settings["AutoPredict"] = bool
end)
Main.newToggle("Smooth Camlock","Makes the camlock smooth.", true, function(bool)
    settings["Smoothing"] = bool
end)
Main.newToggle("Resolver","Antilock resolver.", false, function(bool)
    settings["Resolver"] = bool
end)
Main.newToggle("Knock Check","Disables lock when knocked (legit).", true, function(bool)
    settings["KnockCheck"] = bool
end)
Main.newToggle("Scriptable Camera", "Makes your camera scriptable when lock is on. (helps with camlock a lot)", false, function(bool)
    settings["Scriptable"] = bool
end)
Main.newToggle("Anti-lock","Turns anti-lock on/off.", false, function(bool)
    settings["Antilock"] = bool
end)
Main.newToggle("Auto Stomp","Auto stomps whenever you walk on someone's body.", false, function(bool)
    settings["AutoStomp"] = bool
    if settings["AutoStomp"] then
        autostomp()
    end
end)
Main.newToggle("Auto Food","Spawns you with food and rebuys when eaten.", true, function(bool)
    settings["AutoFood"] = bool
end)
Main.newToggle("Auto Tactical","Auto buys tactical shotgun when not in inventory.", false, function(bool)
    settings["AutoTactical"] = bool
end)
Main.newButton("Custom Macro View", "Fixes the macro button and makes it third person.", function()
    local LS = game.Players.LocalPlayer.PlayerScripts.Macro
    for i, v in pairs(getsenv(LS)) do
        for _, cons in getconstants(getsenv(LS).inout) do
            setconstant(getsenv(LS).inout, 1, 8)
        end
    end
end)

--// Misc Stuff:
Misc.newButton("Lock Button", "Creates a lock button", function()
    if not game:GetService("CoreGui").ButtonHandler:FindFirstChild("L") then
        ButtonsModule.lockButton("L")
    end
    
    lockbutton = game:GetService("CoreGui").ButtonHandler.L
    
    lockbutton.MouseButton1Click:Connect(function()
        local silentbuttoncheck = game.CoreGui:FindFirstChild("ButtonHandler"):FindFirstChild("S")
        if game.Players:FindFirstChild(settings["Target"]) then
            if not settings["Camlock"] then
                settings["Camlock"] = true
                camlock()
                Notify("Lock Notif", "  Target: "..settings["Target"], 1)
                settings["Silent"] = false
                lockbutton.Text = "Unlock"
                silentbutton.Text = "Silent lock"
            else
                settings["Camlock"] = false
                lockbutton.Text = "Lock"
            end
        else
            settings["Camlock"] = false
            lockbutton.Text = "Lock"
        end
    end)
    Notify("Button Notif", "Lock button has been successfully created!", 1)
end)
Misc.newButton("Silent Button", "Creates a silent button", function()
    if not game:GetService("CoreGui").ButtonHandler:FindFirstChild("S") then
        ButtonsModule.silentButton("S")
    end
    
    silentbutton = game:GetService("CoreGui").ButtonHandler.S
    
    silentbutton.MouseButton1Click:Connect(function()
        local lockbutton = game.CoreGui:FindFirstChild("ButtonHandler"):FindFirstChild("L")
        if not settings["Silent"] then
            settings["Silent"] = true
            silentlock()
            settings["Camlock"] = false
            silentbutton.Text = "Unlock"
            lockbutton.Text = "Lock"
        else
            settings["Silent"] = false
            silentbutton.Text = "Silent lock"
        end
    end)
    Notify("Button Notif", "Silent button has been successfully created!", 1)
end)
Misc.newButton("Armour Button", "Creates a armour button", function()
    if not game:GetService("CoreGui").ButtonHandler:FindFirstChild("A") then
        ButtonsModule.armourButton("A")
    end
    
    armourbutton = game:GetService("CoreGui").ButtonHandler.A
    
    armourbutton.MouseButton1Click:Connect(function()
        if not settings["AutoArmour"] then
            settings["AutoArmour"] = true
            armourbutton.BackgroundColor3 = Color3.fromRGB(215,40,20)
            armourbutton.Text = "Stop Auto Armour"
        else
            settings["AutoArmour"] = false
            armourbutton.BackgroundColor3 = Color3.fromRGB(5,190,10)
            armourbutton.Text = "Auto Armour"
        end
    end)
    Notify("Button Notif", "Armour button has been successfully created!", 1)
end)
Misc.newButton("DESTROY ALL BUTTONS", "", function()
    local handler = game:FindFirstChild("CoreGui"):FindFirstChild("ButtonHandler") or game.CoreGui.ButtonHandler
    for _, button in handler:GetChildren() do
        button:Destroy()
    end
    Notify("DESTROYED BUTTONS", "Destroyed all buttons successfully", 1)
end)

--// Settings stuff:
Setting.newDropdown("Anti-lock Position", "Adjusts the position of the anti-lock.", { "Sky", "Ground", "Troll", "Prediction" }, function(picked)
    settings["AntiPosition"] = picked
end)
Setting.newDropdown("Aimpart", "Adjusts the part of the camlock.", settings["Aimparts"], function(picked)
    settings["Aimpart"] = picked
end)
Setting.newDropdown("Resolve Type", "Adjusts the anti-lock resolver type.", { "Recalculate velocity", "Horizontal", "Zero" }, function(picked)
    settings["ResolverType"] = picked
end)
Setting.newInput("Aimlock Prediction Amount", "Adjusts the aimlock prediction.", function(inp)
    settings["AimlockPrediction"] = tonumber(inp)
end)
Setting.newInput("Auto Prediction Amount", "Adjusts the ping-based prediction (MUST BE 0.00number).", function(inp)
    settings["AutoPrediction"] = tonumber(inp)
end)
Setting.newInput("Prediction Amount", "Adjusts the prediction.", function(inp)
    settings["Prediction"] = tonumber(inp)
end)
Setting.newInput("Smoothening Amount", "Adjusts the smoothening amount.", function(inp)
    settings["SmoothingAmount"] = tonumber(inp)
end)
Setting.newInput("Auto Stomp Delay", "Adjusts the auto stomp delay.", function(inp)
    settings["AutoStompDelay"] = tonumber(inp)
end)

--[[
local mt = getrawmetatable(game)
local old = mt.__namecall
local AntiCheatNamecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local args = {...}
    local name = {"MOUSE", "UpdateMousePos", "Mouse"}
    if self.Name == "MAINEVENT" then
        if settings["Aimlock"] and tostring(getnamecallmethod()) == "FireServer" and table.find(name, args[1]) then
            local target = game.Players[settings["Target"]]
            if target then
                local pos = target.Character[settings["Aimpart"]].Position
                local cf = target.Character[settingd["Aimpart"]].CFrame
                local vel = target.Character[settings["Aimpart"]].Velocity
                
                local final = pos+(vel*settings["Prediction"])
                args[2] = final
            else print("target does not exist.") end
            --return old(self, unpack(args))
        end
    end
    return old(self, ...)
end)

AntiCheatNamecall = hookmetamethod(game, "__namecall", newcclosure(function(Self, ...)
    local Arguments = {...}
    local AntiCheats = {"BreathingHAMON", "TeleportDetect", "JJARC", "TakePoisonDamage", "CHECKER_1", "CHECKER", "GUI_CHECK", "OneMoreTime", "checkingSPEED", "BANREMOTE", "PERMAIDBAN", "KICKREMOTE", "BR_KICKPC", "FORCEFIELD", "Christmas_Sock", "VirusCough", "Symbiote", "Symbioted", "RequestAFKDisplay"}
    
    if table.find(AntiCheats, Arguments[1]) and getnamecallmethod() == "FireServer" then
        return
    end
    
    return AntiCheatNamecall(Self, ...)
end))
]]